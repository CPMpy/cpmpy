#!/usr/bin/env python
# -*- coding:utf-8 -*-
##
## minizinc.py
##
"""
    Interface to the python 'minizinc' package

    Requires that the 'minizinc' python package is installed:

        $ pip install minizinc
    
    as well as the MiniZinc bundled binary packages, downloadable from:
    https://www.minizinc.org/software.html

    Note for Jupyter users: MiniZinc uses AsyncIO, so using it in a jupyter notebook gives
    you the following error: RuntimeError: asyncio.run() cannot be called from a running event loop
    You can overcome this by `pip install nest_asyncio`
    and adding in the top cell `import nest_asyncio; nest_asyncio.apply()`

    ===============
    List of classes
    ===============

    .. autosummary::
        :nosignatures:

        CPM_minizinc

    ==============
    Module details
    ==============
"""

import numpy as np
import sys
from datetime import timedelta # for mzn's timeout
from .solver_interface import SolverInterface, ExitStatus, SolverStatus
from ..transformations.get_variables import get_variables_model, get_variables
from ..expressions.variables import _NumVarImpl, _IntVarImpl, _BoolVarImpl, NegBoolView
from ..expressions.core import Expression, Comparison, Operator
from ..expressions.utils import is_num, is_any_list, flatlist


class CPM_minizinc(SolverInterface):
    """
    Creates the following attributes:

    user_vars: variables used in the model (without auxiliaries),
               these variables' .value() will be backpopulated on solve
    mzn_solve: the minizinc.Solver instance
    mzn_model: the minizinc.Model instance
    mzn_txt_solve: the 'solve' item in text form, so it can be overwritten
    """

    @staticmethod
    def supported():
        """
            Make sure you installed the minizinc distribution from minizinc.org
            as well as installing the 'minizinc-python' package (e.g. pip install minizinc)
        """
        try:
            import minizinc
            return True
        except ImportError as e:
            return False

    @staticmethod
    def solvernames():
        """
            Returns solvers supported by MiniZinc on your system

            WARNING, some of them may not actually be installed on your system
            (namely cplex, gurobi, scip, xpress)
            the following are bundled in the bundle: chuffed, coin-bc, gecode
        """
        import minizinc
        import json
        # from minizinc.Solver.lookup()
        out = minizinc.default_driver.run(["--solvers-json"])
        out_lst = json.loads(out.stdout)

        solvers = []
        for s in out_lst:
            name = s["id"].split(".")[-1]
            if name not in ['findmus', 'gist', 'globalizer']:  # not actually solvers
                solvers.append(name)
        return solvers

    header = "% Generated by CPMpy\ninclude \"globals.mzn\";\n\n"


    def __init__(self, cpm_model=None, subsolver=None):
        """
        Constructor of the solver object

        Requires a CPMpy model as input, and will create the corresponding
        minizinc model and solver object (mzn_model and mzn_solver)

        solver has to be one of solvernames() [str, default: None]
        """
        if not self.supported():
            raise Exception(
                "Install the python 'minizinc-python' package to use this 'minizinc' solver interface")
        import minizinc

        # determine subsolver
        if subsolver is None or subsolver == 'minizinc':
            # default solver
            subsolver = "gecode"
        elif subsolver.startswith('minizinc:'):
            subsolver = subsolver[9:] # strip 'minizinc:'

        # create the solver instance
        # (so its params can still be changed before calling solve)
        self.mzn_solver = minizinc.Solver.lookup(subsolver)
        self.mzn_model = minizinc.Model()

        # Add header, prepare solve statement
        self.mzn_model.add_string(CPM_minizinc.header)
        self.mzn_txt_solve = "solve satisfy;"

        super().__init__(name="minizinc:"+subsolver, cpm_model=cpm_model)


    def __add__(self, cons):
        """
            Add an additional (list of) constraints to the model
        """
        # Add variables in cons
        self.user_vars.update(get_variables(cons))

        if not is_any_list(cons):
            cons = [cons]

        # we can't unpack lists in convert_expression, so must do it upfront
        # and can't make assumptions on '.flat' existing either...
        cons = flatlist(cons)
        for con in cons:
            self._post_constraint(con)
        return self

    def _pre_solve(self, time_limit=None, **kwargs):
        """ shared by solve() and solveAll() """
        import minizinc

        # set time limit?
        if time_limit is not None:
            kwargs['timeout'] = timedelta(seconds=time_limit)

        # hack, we need to add the objective in a way that it can be changed
        # later, so make copy of the mzn_model
        copy_model = self.mzn_model.__copy__() # it is implemented
        copy_model.add_string(self.mzn_txt_solve)
        # Transform Model into an instance
        mzn_inst = minizinc.Instance(self.mzn_solver, copy_model)

        kwargs['output-time'] = True # required for time getting
        return (kwargs, mzn_inst)
        # we can't unpack lists in convert_expression, so must do it upfront
        # and can't make assumptions on '.flat' existing either...
        cons = flatlist(cons)
        for con in cons:
            self._post_constraint(con)
        return self

    def minimize(self, expr):
        """
            Minimize the given objective function

            `minimize()` can be called multiple times, only the last one is stored
        """
        # do not add it to the model, support only one 'solve' entry
        self.mzn_txt_solve = "solve minimize {};\n".format(self._convert_expression(expr))

    def maximize(self, expr):
        """
            Maximize the given objective function

            `maximize()` can be called multiple times, only the last one is stored
        """
        # do not add it to the model, support only one 'solve' entry
        self.mzn_txt_solve = "solve maximize {};\n".format(self._convert_expression(expr))

    def solve(self, time_limit=None, **kwargs):
        """
            Create and call an Instance with the already created mzn_model and mzn_solver

            Arguments:
            - time_limit:  maximum solve time in seconds (float, optional)

            Additional keyword arguments:
            The minizinc solver parameters are partly defined in its API:
            https://minizinc-python.readthedocs.io/en/latest/api.html#minizinc.instance.Instance.solve

            You can use any of these parameters as keyword argument to `solve()` and they will
            be forwarded to the solver. Examples include:
                - free_search=True              Allow the solver to ignore the search definition within the instance. (Only available when the -f flag is supported by the solver). (Default: 0)
                - optimisation_level=0          Set the MiniZinc compiler optimisation level. (Default: 1; 0=none, 1=single pass, 2=double pass, 3=root node prop, 4,5=probing)
                - ...                           I am not sure where solver-specific arguments are documented, but the docs say that command line arguments can be passed by ommitting the '-' (e.g. 'f' instead of '-f')?

            example:
            o.solve(free_search=True, optimisation_level=0)

            Does not store the minizinc.Instance() or minizinc.Result() (can be deleted)
        """
        # make mzn_inst
        (mzn_kwargs, mzn_inst) = self._pre_solve(time_limit=time_limit, **kwargs)
        mzn_result = mzn_inst.solve(**mzn_kwargs)

        # translate solution values (of original vars only)
        self.objective_value_ = None
        if mzn_result.status.has_solution():
            # runtime
            mznsol = mzn_result.solution
            if is_any_list(mznsol):
                print("Warning: multiple solutions found, only returning last one")
                mznsol = mznsol[-1]

            # fill in variables
            for var in self.user_vars:
                varname = self.clean_varname(var.name)
                if hasattr(mznsol, varname):
                    var._value = getattr(mznsol, varname)
                else:
                    print("Warning, no value for ",varname)

            # translate objective (if any, otherwise None)
            self.objective_value_ = mzn_result.objective

        # handle status
        self._post_solve(mzn_result)
        return self._solve_return(self.cpm_status)

    def _post_solve(self, mzn_result):
        """ shared by solve() and solveAll() """
        import minizinc

        mzn_status = mzn_result.status
        # translate status
        self.cpm_status = SolverStatus(self.name)
        if mzn_status == minizinc.result.Status.SATISFIED:
            self.cpm_status.exitstatus = ExitStatus.FEASIBLE
        elif mzn_status == minizinc.result.Status.ALL_SOLUTIONS:
            self.cpm_status.exitstatus = ExitStatus.FEASIBLE
        elif mzn_status == minizinc.result.Status.OPTIMAL_SOLUTION:
            self.cpm_status.exitstatus = ExitStatus.OPTIMAL
        elif mzn_status == minizinc.result.Status.UNSATISFIABLE:
            self.cpm_status.exitstatus = ExitStatus.UNSATISFIABLE
        elif mzn_status == minizinc.result.Status.ERROR:
            self.cpm_status.exitstatus = ExitStatus.ERROR
            raise Exception("MiniZinc solver returned with status 'Error'")
        elif mzn_status == minizinc.result.Status.UNKNOWN:
            # means, no solution was found (e.g. within timeout?)...
            self.cpm_status.exitstatus = ExitStatus.ERROR
        else:
            raise NotImplementedError  # a new status type was introduced, please report on github

        # translate runtime
        if 'time' in mzn_result.statistics:
            self.cpm_status.runtime = mzn_result.statistics['time']  # --output-time

        return self.cpm_status

    async def _solveAll(self, display=None, time_limit=None, solution_limit=None, **kwargs):
        """ Special 'async' function because mzn.solutions() is async """
        # make mzn_inst
        (kwargs, mzn_inst) = self._pre_solve(time_limit=time_limit, **kwargs)
        kwargs['all_solutions'] = True

        solution_count = 0
        # has an asynchronous generator
        async for mzn_result in mzn_inst.solutions(**kwargs):
            # was the last one
            if mzn_result.solution is None:
                break

            # display (and reverse-map first) if needed
            if display:
                mznsol = mzn_result.solution
                # fill in variables
                for var in self.user_vars:
                    varname = self.clean_varname(var.name)
                    if hasattr(mznsol, varname):
                        var._value = getattr(mznsol, varname)
                    else:
                        print("Warning, no value for ",varname)

                # and the actual displaying
                if isinstance(display, Expression):
                    print(display.value())
                elif isinstance(display, list):
                    print([v.value() for v in display])
                else:
                    display() # callback

            # count and stop
            solution_count += 1
            if solution_count == solution_limit:
                break

            # add nogood on the user variables
            self += any([v != v.value() for v in self.user_vars])

        # status handling
        self._post_solve(mzn_result)

        return solution_count

    def objective_value(self):
        """
            Returns the value of the objective function of the latste solver run on this model

        :return: an integer or 'None' if it is not run, or a satisfaction problem
        """
        return self.objective_value_

    def solver_var(self, cpm_var):
        """
            Transforms the variable into a minizinc-string
            Returns minizinc-friendly name of var
        """
        if is_num(cpm_var):
            return cpm_var

        if cpm_var not in self._varmap:
            mzn_var = self.clean_varname(cpm_var.name)
            self._varmap[cpm_var] = mzn_var

            if isinstance(cpm_var, _BoolVarImpl):
                self.mzn_model.add_string(f"var bool: {mzn_var};\n")
            elif isinstance(cpm_var, _IntVarImpl):
                self.mzn_model.add_string(f"var {cpm_var.lb}..{cpm_var.ub}: {mzn_var};\n")

        return self._varmap[cpm_var]

    def _post_constraint(self, cpm_expr):
        """
            Posts a primitive CPMpy constraint to the native minizinc solver API
        """
        # Post variables to solver
        cpm_vars = get_variables(cpm_expr)
        for var in cpm_vars:
            _ = self.solver_var(var)

        # Post constraint to solver
        txt_cons = f"constraint {self._convert_expression(cpm_expr)};\n"
        self.mzn_model.add_string(txt_cons)

    def clean_varname(self, varname):
        return varname.replace(',', '_').replace('.', '_').replace(' ', '_').replace('[', '_').replace(']', '')

    def _convert_expression(self, expr) -> str:
        """
            Convert a CPMpy expression into a minizinc-compatible string

            recursive: also converts nested subexpressions
        """
        if is_any_list(expr):
            if isinstance(expr, np.ndarray):
                # must flatten
                expr_str = [self._convert_expression(e) for e in expr.flat]
            else:
                expr_str = [self._convert_expression(e) for e in expr]
            if len(expr_str) == 1:
                # unary special case, don't put in list
                return expr_str[0]
            else:
                return "[{}]".format(",".join(expr_str))

        if not isinstance(expr, Expression) or \
                isinstance(expr, _NumVarImpl):
            if expr is True:
                return "true"
            if expr is False:
                return "false"
            # default
            if isinstance(expr, NegBoolView):
                return "not " + self.solver_var(expr._bv)
            return str(self.solver_var(expr))

        # table(vars, tbl): no [] nesting of args, and special table output...
        if expr.name == "table":
            str_vars = self._convert_expression(expr.args[0])
            str_tbl = "[|\n"  # opening
            for row in expr.args[1]:
                str_tbl += ",".join(map(str, row)) + " |"  # rows
            str_tbl += "\n|]"  # closing
            return "table({}, {})".format(str_vars, str_tbl)

        args_str = [self._convert_expression(e) for e in expr.args]

        # standard expressions: comparison, operator, element
        if isinstance(expr, Comparison):
            # pretty printing: add () if nested comp/op
            for e in expr.args:
                if isinstance(e, (Comparison, Operator)):
                    for i in [0, 1]:
                        args_str[i] = "({})".format(args_str[i])
            # infix notation
            return "{} {} {}".format(args_str[0], expr.name, args_str[1])

        elif isinstance(expr, Operator):
            # some names differently (the infix names!)
            printmap = {'and': '/\\', 'or': '\\/',
                        'sum': '+', 'sub': '-',
                        'mul': '*', 'div': '/', 'pow': '^'}
            op_str = expr.name
            if op_str in printmap:
                op_str = printmap[op_str]

            # TODO: pretty printing of () as in Operator?

            # special case: unary -
            if self.name == '-':
                return "-{}".format(args_str[0])

            # very special case: weighted sum (before 2-ary)
            if expr.name == 'wsum':
                # I don't think there is a more direct way unfortunately
                w = [self._convert_expression(wi) for wi in expr.args[0]]
                x = [self._convert_expression(xi) for xi in expr.args[1]]
                args_str = [f"{wi}*{xi}" for wi,xi in zip(w,x)]
                return "{}([{}])".format("sum", ",".join(args_str))

            # special case, infix: two args
            if len(args_str) == 2:
                for i, arg_str in enumerate(args_str):
                    if isinstance(expr.args[i], Expression):
                        args_str[i] = "(" + args_str[i] + ")"
                return "{} {} {}".format(args_str[0], op_str, args_str[1])

            # special case: n-ary (non-binary): rename operator
            printnary = {'and': 'forall', 'or': 'exists', 'xor': 'xorall', 'sum': 'sum'}
            if expr.name in printnary:
                op_str = printnary[expr.name]
                return "{}([{}])".format(op_str, ",".join(args_str))

            # default: prefix printing
            return "{}({})".format(op_str, ",".join(args_str))

        elif expr.name == "element":
            subtype = "int"
            if all(isinstance(v, bool) or \
                   (isinstance(v, Expression) and v.is_bool()) \
                   for v in expr.args[0]):
                subtype = "bool"
            idx = args_str[1]
            # minizinc is offset 1, which can be problematic for element...
            # thx Hakan, fix by using array1d(0..len, []), issue #54
            txt = "\n    let {{ array[int] of var {}: arr=array1d({}..{},{}) }} in\n".format(subtype, 0,
                                                                                             len(expr.args[0]) - 1,
                                                                                             args_str[0])
            txt += f"      arr[{idx}]"
            return txt

        # rest: global constraints
        elif expr.name.endswith('circuit'):  # circuit, subcircuit
            # minizinc is offset 1, which can be problematic here...
            if any(isinstance(e, _IntVarImpl) and e.lb == 0 for e in expr.args):
                # redo args_str[0]
                args_str = ["{}+1".format(self._convert_expression(e)) for e in expr.args]

        # default (incl name-compatible global constraints...)
        return "{}([{}])".format(expr.name, ",".join(args_str))

    def solveAll(self, display=None, time_limit=None, solution_limit=None, **kwargs):
        """
            Compute all solutions and optionally display the solutions.

            MiniZinc-specific implementation

            Arguments:
                - display: either a list of CPMpy expressions, OR a callback function, called with the variables after value-mapping
                        default/None: nothing displayed
                - time_limit: stop after this many seconds (default: None)
                - solution_limit: stop after this many solutions (default: None)
                - any other keyword argument

            Returns: number of solutions found
        """
        # XXX: check that no objective function??
        import asyncio

        # HAD TO DEFINE OUR OWN ASYNC HANDLER
        coroutine = self._solveAll(display=display, time_limit=time_limit,
                                    solution_limit=solution_limit, **kwargs)
        # THE FOLLOWING IS STRAIGHT FROM `minizinc.instance.solve()`
        # LETS HOPE IT DOES NOT DIVERGE FROM UPSTREAM
        if sys.version_info >= (3, 7):
            if sys.platform == "win32":
                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
            return asyncio.run(coroutine)
        else:
            if sys.platform == "win32":
                loop = asyncio.ProactorEventLoop()
            else:
                loop = asyncio.events.new_event_loop()

            try:
                asyncio.events.set_event_loop(loop)
                return loop.run_until_complete(coroutine)
            finally:
                asyncio.events.set_event_loop(None)
                loop.close()
