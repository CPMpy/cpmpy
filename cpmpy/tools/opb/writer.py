"""
    This file implements helper functions for exporting CPMpy models from and to OPB format.
    OPB is a textual format to represent Pseudo-Boolean problems.
    The header of the file is formatted as ``* #variable= <n_vars> #constraint= <n_constraints>``.
    If the number of variables and constraints are not given, it is inferred by the writer.

    Each remaining line of the file is formatted as a constraint.
    A constraint is formatted as a string of integers.
    An integer represents a Boolean variable and a negative Boolean variable is represented using a `'-'` sign.
"""

import cpmpy as cp

from cpmpy.transformations.normalize import toplevel_list,simplify_boolean
from cpmpy.transformations.safening import no_partial_functions, safen_objective
from cpmpy.transformations.decompose_global import decompose_in_tree, decompose_objective
from cpmpy.transformations.flatten_model import flatten_constraint, flatten_objective
from cpmpy.transformations.reification import only_implies, only_bv_reifies
from cpmpy.transformations.linearize import linearize_constraint, only_positive_bv_wsum
from cpmpy.transformations.int2bool import int2bool, _encode_lin_expr
from cpmpy.transformations.get_variables import get_variables
from cpmpy.expressions.variables import _IntVarImpl, NegBoolView, _BoolVarImpl
from cpmpy.expressions.core import Operator, Comparison

from cpmpy import __version__

def write_opb(model, fname=None, encoding="auto"):
    """
    Writes CPMpy model to OPB format

    :param model: a CPMpy model
    :param fname: optional, file name to write the OPB output to, if None, the output is returned as a string
    :param encoding: the encoding used for `int2bool`, choose from ("auto", "direct", "order", or "binary")
    """

    # Transform the model into a list of (reified) Pseudo-Boolean constraints.
    csemap, ivarmap = dict(), dict()
    opb_cons = _transform(model.constraints, csemap, ivarmap, encoding)

    if model.objective_ is not None:
        opb_obj, const, extra_cons = _transform_objective(model.objective_, csemap, ivarmap, encoding)
        opb_cons += extra_cons
    else:
        opb_obj = None

    # Write the header of the file
    out = [f"* #variable=: {len(get_variables(opb_cons+ [opb_obj]))} #constraint=: {len(opb_cons)}"]
    out += ["* OPB file generated by CPMpy version {}".format(__version__)]

    # Some solvers only support x<int> as variable names, so we rename the variables here.
    varmap = {v: f"x{i+1}" for i, v in enumerate(get_variables(opb_cons))}
    
    # Write the objective function
    if model.objective_ is not None:
        if model.objective_is_min:
            out.append(f"min: {_wsum_to_str(opb_obj, varmap)};")
        else:
            out.append(f"max: {_wsum_to_str(opb_obj, varmap)};")

    # Write the constraints
    for cons in opb_cons:
        out.append(f"{_wsum_to_str(cons, varmap)};")

    if fname is None:
        return "\n".join(out)
    else:
        with open(fname, "w") as f:
            f.write("\n".join(out))

def _normalized_comparison(lst_of_expr):

    newlist = []
    for cpm_expr in lst_of_expr:
        if isinstance(cpm_expr, cp.BoolVal) and cpm_expr.value() is False:
                raise NotImplementedError(f"Cannot transform {cpm_expr} to OPB constraint")
            
        if isinstance(cpm_expr, _BoolVarImpl):
            cpm_expr = Operator("sum", [cpm_expr]) >= 1

        if isinstance(cpm_expr, Comparison):
            lhs, rhs = cpm_expr.args

            if isinstance(lhs, _BoolVarImpl):
                lhs = Operator("sum", [lhs])
            elif lhs.name == "sum":
                lhs = Operator("wsum", [[1]*len(lhs.args), lhs.args])

            if cpm_expr.name == "==":
                newlist += _normalized_comparison([lhs <= rhs])
                newlist += _normalized_comparison([lhs >= rhs])
            elif cpm_expr.name == ">=":
                newlist.append(lhs >= rhs)
            elif cpm_expr.name == "<=":
                new_weights = [-w for w in lhs.args[0]]
                newlist.append(Operator("wsum", [new_weights, lhs.args]) >= -rhs)
            else:
                raise ValueError(f"Unknown comparison {cpm_expr.name}")
        else:
            raise NotImplementedError(f"Expected a comparison, but got {cpm_expr}")

    return newlist
            

    

    assert isinstance(cpm_expr, Comparison), f"Expected a comparison, but got {cpm_expr}"
    lhs, rhs = cpm_expr.args
    if isinstance(lhs, _BoolVarImpl):
        lhs = Operator("sum", [lhs])
    elif lhs.name == "sum":
        lhs = Operator("wsum", [[1]*len(lhs.args), lhs.args])
    
    if cpm_expr.name == "==":
        return _normalized_comparison(lhs <= rhs) + _normalized_comparison(lhs >= rhs)
    
    
    return [cpm_expr]


def _wsum_to_str(cpm_expr, varmap):

    assert isinstance(cpm_expr, Operator) and cpm_expr.name == "wsum", f"Expected a wsum, but got {cpm_expr}"
    weights, args = cpm_expr.args

    out = []
    for w, var in zip(weights, args):
        if w < 0:
            out.append(f"- {w} {varmap[var]}")
        elif w > 0:
            out.append(f"+ {w} {varmap[var]}")
        else:
            pass # zero weight, ignore
    
    str_out = " ".join(out)
    return str_out

def _header(opb_cons):
    return f"* #variable= {len(vars)} #constraint= {len(opb_cons)}"


def _transform(cpm_expr, csemap, ivarmap, encoding="auto"):
    """
        Transform a list of CPMpy expressions into a list of Pseudo-Boolean constraints.
    """

    cpm_cons = toplevel_list(cpm_expr)
    cpm_cons = no_partial_functions(cpm_cons, safen_toplevel={"div", "mod", "element"})
    cpm_cons = decompose_in_tree(cpm_cons,
        supported={"alldifferent"},  # alldiff has a specialized MIP decomp in linearize
        csemap=csemap
    )
    cpm_cons = simplify_boolean(cpm_cons)
    cpm_cons = flatten_constraint(cpm_cons, csemap=csemap)  # flat normal form
    cpm_cons = only_bv_reifies(cpm_cons, csemap=csemap)
    cpm_cons = only_implies(cpm_cons, csemap=csemap)
    cpm_cons = linearize_constraint(
        cpm_cons, supported=frozenset({"sum", "wsum"}), csemap=csemap
    )
    cpm_cons = int2bool(cpm_cons, ivarmap, encoding=encoding)

    return _normalized_comparison(cpm_cons)

def _transform_objective(expr, csemap, ivarmap, encoding="auto"):

    # transform objective
    obj, safe_cons = safen_objective(expr)
    obj, decomp_cons = decompose_objective(obj, supported={"alldifferent"},
                                            csemap=csemap)
    obj, flat_cons = flatten_objective(obj, csemap=csemap)
    obj = only_positive_bv_wsum(obj)  # remove negboolviews

    weights, xs, const = [], [], 0
    # we assume obj is a var, a sum or a wsum (over int and bool vars)
    if isinstance(obj, _IntVarImpl) or isinstance(obj, NegBoolView):  # includes _BoolVarImpl
        weights = [1]
        xs = [obj]
    elif obj.name == "sum":
        xs = obj.args
        weights = [1] * len(xs)
    elif obj.name == "wsum":
        weights, xs = obj.args
    else:
        raise NotImplementedError(f"OPB: Non supported objective {obj} (yet?)")

    terms, cons, k = _encode_lin_expr(ivarmap, xs, weights, encoding)

    # remove terms with coefficient 0 (`only_positive_coefficients_` may return them and RC2 does not accept them)
    terms = [(w, x) for w,x in terms if w != 0]  

    obj = cp.sum(w * x for w, x in terms)
    return obj, const, safe_cons + decomp_cons + flat_cons


if __name__ == "__main__":

    import cpmpy as cp

    x = cp.boolvar(shape=(3,4), name="y")

    model = cp.Model()
    model += x.sum(axis=1) >= 1
    model += x.sum(axis=0) <= 1
    
    # print(model)

    print(write_opb(model))