#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test script to check if solvers support incremental satisfiability solving and optimization.


!!!!
This code was generated by an LLM, with limited proofchecking (its too alien).
The code can be disposed off or re-prompted at any time.
"""

import time
import cpmpy as cp
from cpmpy.solvers.utils import SolverLookup


def create_sat_problem(n_bool=140, n_int=10, n_iterations=10):
    """Create a harder pseudo-Boolean test problem that benefits from incremental solving."""
    # Mix of Boolean and integer variables
    b = cp.boolvar(shape=n_bool, name="b")
    x = cp.intvar(0, 20, shape=n_int, name="x")  # Small integer domains
    
    # Partition integers into 4 groups and add AllDifferent on each group
    n_groups = 4
    group_size = n_int // n_groups
    all_diff_constraints = []
    for i in range(n_groups):
        start_idx = i * group_size
        end_idx = start_idx + group_size if i < n_groups - 1 else n_int
        if end_idx - start_idx > 1:
            all_diff_constraints.append(cp.AllDifferent(x[start_idx:end_idx]))
    
    # Base constraints - make it harder
    base_constraints = [
        cp.sum(b) >= n_bool // 3,  # At least 1/3 of booleans true
        cp.sum(b) <= n_bool * 2 // 3,  # At most 2/3 of booleans true
        cp.sum(x) >= 5,  # Sum of integers
        cp.sum(x) <= 150,
    ] + all_diff_constraints  # Add AllDifferent constraints on integer groups
    
    # Additional constraints to add incrementally - progressively harder
    incremental_constraints = []
    for i in range(n_iterations):
        bool_idx = i % n_bool
        int_idx = i % n_int
        
        iteration_constraints = [
            # Boolean constraints
            b[bool_idx].implies(b[(bool_idx + 1) % n_bool]),  # Implications
            cp.sum(b[bool_idx:min(bool_idx+3, n_bool)]) >= 1,  # At least one true
            # Integer constraints with smaller domains
            x[int_idx] <= 18 - i,  # Tighter bounds
            x[int_idx] >= 2 + i // 2,
            # Pseudo-Boolean: mix of bool and int
            cp.sum(b[bool_idx:min(bool_idx+5, n_bool)]) + x[int_idx] <= 15 + i,
        ]
        if i >= 3:
            # Add more complex pseudo-Boolean constraints
            start_bool = (i * 2) % n_bool
            start_int = (i * 2) % n_int
            iteration_constraints.append(
                cp.sum(b[start_bool:min(start_bool+4, n_bool)]) + 
                cp.sum(x[start_int:min(start_int+2, n_int)]) >= 3
            )
        incremental_constraints.append(iteration_constraints)
    
    return base_constraints, incremental_constraints


def create_opt_problem(n_bool=140, n_int=10):
    """Create a pseudo-Boolean optimization problem."""
    # Mix of Boolean and integer variables
    b = cp.boolvar(shape=n_bool, name="b")
    x = cp.intvar(0, 20, shape=n_int, name="x")
    
    # Partition integers into 4 groups and add AllDifferent on each group
    n_groups = 4
    group_size = n_int // n_groups
    all_diff_constraints = []
    for i in range(n_groups):
        start_idx = i * group_size
        end_idx = start_idx + group_size if i < n_groups - 1 else n_int
        if end_idx - start_idx > 1:
            all_diff_constraints.append(cp.AllDifferent(x[start_idx:end_idx]))
    
    # Fixed constraints
    constraints = [
        cp.sum(b) >= n_bool // 3,
        cp.sum(b) <= n_bool * 2 // 3,
        cp.sum(x) >= 5,
        cp.sum(x) <= 150,
    ] + all_diff_constraints
    
    return b, x, constraints


def create_objectives(b, x, n_iterations=10):
    """Create a list of objectives that change across iterations."""
    objectives = []
    for i in range(n_iterations):
        # Vary the objective: mix of boolean and integer components
        bool_idx = (i * 7) % len(b)
        int_idx = (i * 3) % len(x)
        # Change weights and components across iterations
        obj = (cp.sum(b[bool_idx:min(bool_idx+10, len(b))]) * (10 + i) + 
               cp.sum(x[int_idx:min(int_idx+3, len(x))]) * (5 - i // 2))
        objectives.append(obj)
    return objectives


def solve_repeatedly(solver_name, base_constraints, incremental_constraints, incremental=True):
    """
    Solve problem repeatedly, adding constraints incrementally.
    
    Args:
        solver_name: Name of the solver to use
        base_constraints: Initial constraints
        incremental_constraints: List of constraint lists to add iteratively
        incremental: If True, use SolverLookup (incremental). If False, use Model (non-incremental).
    
    Returns:
        List of solve times for each iteration
    """
    solve_times = []
    
    if incremental:
        # Create solver once and reuse it
        solver = SolverLookup.get(solver_name)
        for con in base_constraints:
            solver += con
    else:
        # Create model (new solver each solve)
        solver = cp.Model(base_constraints)
    
    # Solve initial problem
    start = time.perf_counter()
    if incremental:
        result = solver.solve()  # Solver instance, no solver parameter needed
    else:
        result = solver.solve(solver=solver_name)  # Model, specify solver
    solve_times.append(time.perf_counter() - start)
    
    if not result:
        return solve_times  # UNSAT
    
    # Iteratively add constraints and solve
    for constraints in incremental_constraints:
        if incremental:
            # Add to solver directly
            for con in constraints:
                solver += con
        else:
            # Add to model
            solver += constraints
        
        start = time.perf_counter()
        if incremental:
            result = solver.solve()  # Solver instance
        else:
            result = solver.solve(solver=solver_name)  # Model
        solve_times.append(time.perf_counter() - start)
        
        if not result:
            break  # UNSAT
    
    return solve_times


def optimize_repeatedly(solver_name, constraints, objectives, incremental=True):
    """
    Optimize problem repeatedly with changing objectives.
    
    Args:
        solver_name: Name of the solver to use
        constraints: Fixed set of constraints
        objectives: List of objectives to optimize
        incremental: If True, use SolverLookup (incremental). If False, use Model (non-incremental).
    
    Returns:
        List of solve times for each iteration
    """
    solve_times = []
    
    if incremental:
        # Create solver once and reuse it
        solver = SolverLookup.get(solver_name)
        for con in constraints:
            solver += con
    else:
        # Create model (new solver each solve)
        solver = cp.Model(constraints)
    
    # Optimize with each objective
    for obj in objectives:
        if incremental:
            # Set objective on solver
            solver.minimize(obj)
        else:
            # Set objective on model
            solver.minimize(obj)
        
        start = time.perf_counter()
        if incremental:
            result = solver.solve()
        else:
            result = solver.solve(solver=solver_name)
        solve_times.append(time.perf_counter() - start)
        
        if not result:
            break  # UNSAT or optimization failed
    
    return solve_times


def test_satisfiability():
    """Test all available solvers for incremental satisfiability solving support."""
    print("=" * 75)
    print("Testing Incremental Satisfiability Solving")
    print("=" * 75)
    print(f"{'Solver':<20} {'Non-inc (s)':<15} {'Inc (s)':<15} {'Speedup':<10} {'Incremental':<12}")
    print("-" * 75)
    
    # Get all supported solvers
    try:
        available_solvers = SolverLookup.supported()
    except Exception as e:
        print(f"Error getting available solvers: {e}")
        return
    
    if not available_solvers:
        print("No solvers are available on this system.")
        return
    
    # Sort solvers: choco last (it can cause fatal errors)
    available_solvers = sorted(available_solvers, key=lambda s: (s.startswith('choco'), s))
    
    # Create test problem
    base_constraints, incremental_constraints = create_sat_problem(n_bool=140, n_int=10, n_iterations=10)
    
    # Test each solver
    for solver_name in available_solvers:
        try:
            # Test non-incremental
            non_inc_times = solve_repeatedly(solver_name, base_constraints, incremental_constraints, incremental=False)
            if not non_inc_times or len(non_inc_times) == 0:
                print(f"{solver_name:<20} {'UNSAT':<15} {'N/A':<15} {'N/A':<10} {'N/A':<12}")
                continue
            
            # Test incremental
            inc_times = solve_repeatedly(solver_name, base_constraints, incremental_constraints, incremental=True)
            if not inc_times or len(inc_times) == 0:
                print(f"{solver_name:<20} {sum(non_inc_times):.4f}        {'UNSAT':<15} {'N/A':<10} {'N/A':<12}")
                continue
            
            # Compute averages
            non_inc_avg = sum(non_inc_times) / len(non_inc_times)
            inc_avg = sum(inc_times) / len(inc_times)
            
            # Calculate speedup
            speedup = non_inc_avg / inc_avg if inc_avg > 0 else 0
            is_incremental = "yes" if speedup >= 2.0 else "no"
            
            print(f"{solver_name:<20} {non_inc_avg:<15.4f} {inc_avg:<15.4f} {speedup:<10.2f} {is_incremental:<12}")
            
        except Exception as e:
            print(f"{solver_name:<20} {'ERROR':<15} {'ERROR':<15} {'ERROR':<10} {'ERROR':<12}")
    
    print()


def test_optimization():
    """Test all available solvers for incremental optimization support."""
    print("=" * 75)
    print("Testing Incremental Optimization")
    print("=" * 75)
    print(f"{'Solver':<20} {'Non-inc (s)':<15} {'Inc (s)':<15} {'Speedup':<10} {'Incremental':<12}")
    print("-" * 75)
    
    # Get all supported solvers
    try:
        available_solvers = SolverLookup.supported()
    except Exception as e:
        print(f"Error getting available solvers: {e}")
        return
    
    if not available_solvers:
        print("No solvers are available on this system.")
        return
    
    # Sort solvers: choco last (it can cause fatal errors)
    available_solvers = sorted(available_solvers, key=lambda s: (s.startswith('choco'), s))
    
    # Create test problem
    b, x, constraints = create_opt_problem(n_bool=140, n_int=10)
    objectives = create_objectives(b, x, n_iterations=10)
    
    # Test each solver
    for solver_name in available_solvers:
        try:
            # Test non-incremental
            non_inc_times = optimize_repeatedly(solver_name, constraints, objectives, incremental=False)
            if not non_inc_times or len(non_inc_times) == 0:
                print(f"{solver_name:<20} {'UNSAT':<15} {'N/A':<15} {'N/A':<10} {'N/A':<12}")
                continue
            
            # Test incremental
            inc_times = optimize_repeatedly(solver_name, constraints, objectives, incremental=True)
            if not inc_times or len(inc_times) == 0:
                print(f"{solver_name:<20} {sum(non_inc_times):.4f}        {'UNSAT':<15} {'N/A':<10} {'N/A':<12}")
                continue
            
            # Compute averages
            non_inc_avg = sum(non_inc_times) / len(non_inc_times)
            inc_avg = sum(inc_times) / len(inc_times)
            
            # Calculate speedup
            speedup = non_inc_avg / inc_avg if inc_avg > 0 else 0
            is_incremental = "yes" if speedup >= 2.0 else "no"
            
            print(f"{solver_name:<20} {non_inc_avg:<15.4f} {inc_avg:<15.4f} {speedup:<10.2f} {is_incremental:<12}")
            
        except Exception as e:
            print(f"{solver_name:<20} {'ERROR':<15} {'ERROR':<15} {'ERROR':<10} {'ERROR':<12}")


def main():
    """Run both satisfiability and optimization tests."""
    test_satisfiability()
    test_optimization()


if __name__ == "__main__":
    main()

